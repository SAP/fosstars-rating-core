package com.sap.oss.phosphor.fosstars.model.score.oss;

import static com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures.VULNERABILITIES_IN_PROJECT;
import static com.sap.oss.phosphor.fosstars.model.other.Utils.findValue;
import static com.sap.oss.phosphor.fosstars.model.other.Utils.setOf;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonGetter;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.sap.oss.phosphor.fosstars.model.Feature;
import com.sap.oss.phosphor.fosstars.model.Score;
import com.sap.oss.phosphor.fosstars.model.Value;
import com.sap.oss.phosphor.fosstars.model.score.AbstractScore;
import com.sap.oss.phosphor.fosstars.model.value.ScoreValue;
import com.sap.oss.phosphor.fosstars.model.value.Vulnerabilities;
import com.sap.oss.phosphor.fosstars.model.value.Vulnerability;
import java.time.Duration;
import java.time.Instant;
import java.util.Date;
import java.util.Objects;
import java.util.Set;

/**
 * <p>The scores checks how security testing is done
 * and how many vulnerabilities were recently discovered.</p>
 *
 * <ul>
 *   <li>If testing is good, and there are no recent vulnerabilities,
 *   then the score value is max. If there are vulnerabilities, then the score value is high.</li>
 *   <li>If testing is bad, and there are not recent vulnerabilities, then the score value is low.
 *   If there are vulnerabilities, then the score is min.</li>
 * </ul>
 *
 * <p>
 *   The score considers only vulnerabilities that were published in a specific {@link #TIME_FRAME}.
 * </p>
 *
 * <p>
 *   The score uses {@link ProjectSecurityTestingScore} to assess the quality of security testing.
 * </p>
 */
public class VulnerabilityDiscoveryAndSecurityTestingScore extends AbstractScore {

  /**
   * A description of the score.
   */
  private static final String DESCRIPTION
      = "The scores checks how security testing is done "
      + "and how many vulnerabilities were recently discovered. "
      + "If testing is good, and there are no recent vulnerabilities, "
      + "then the score value is max. "
      + "If there are vulnerabilities, then the score value is high. "
      + "If testing is bad, and there are no recent vulnerabilities, "
      + "then the score value is low. "
      + "If there are vulnerabilities, then the score is min.";

  /**
   * Low score value.
   */
  private static final double LOW = 2.0;

  /**
   * High score value.
   */
  private static final double HIGH = 8.0;

  /**
   * A threshold that defines good security testing.
   */
  private static final double GOOD_TESTING_THRESHOLD = 7.0;

  /**
   * The score considers only vulnerabilities that were published during this time frame.
   */
  private static final Duration TIME_FRAME = Duration.ofDays(365);

  /**
   * A score that assesses security testing implemented in an open-source project.
   */
  private final ProjectSecurityTestingScore securityTestingScore;

  /**
   * Initializes a new score.
   *
   * @param securityTestingScore
   *        A score that assesses security testing implemented in an open-source project.
   */
  @JsonCreator
  public VulnerabilityDiscoveryAndSecurityTestingScore(
      @JsonProperty("securityTestingScore") ProjectSecurityTestingScore securityTestingScore) {

    super("Assesses security testing and vulnerability discovery", DESCRIPTION);
    Objects.requireNonNull(securityTestingScore, "Oh no! Security testing score is null!");
    this.securityTestingScore = securityTestingScore;
  }

  /**
   * A getter to make Jackson happy.
   *
   * @return The score for security testing.
   */
  @JsonGetter("securityTestingScore")
  private ProjectSecurityTestingScore securityTestingScore() {
    return securityTestingScore;
  }

  @Override
  public Set<Feature<?>> features() {
    return setOf(VULNERABILITIES_IN_PROJECT);
  }

  @Override
  public Set<Score> subScores() {
    return setOf(securityTestingScore);
  }

  @Override
  public ScoreValue calculate(Value<?>... values) {
    Objects.requireNonNull(values, "Oh no! Values is null");

    Value<Vulnerabilities> vulnerabilities = findValue(values, VULNERABILITIES_IN_PROJECT,
        "Hey! You have to give me info about vulnerabilities");

    ScoreValue securityTestingScoreValue = calculateIfNecessary(securityTestingScore, values);

    ScoreValue scoreValue = scoreValue(MIN, vulnerabilities, securityTestingScoreValue);

    if (allUnknown(scoreValue.usedValues())) {
      return scoreValue.makeUnknown();
    }

    if (securityTestingScoreValue.isNotApplicable() || vulnerabilities.isNotApplicable()) {
      return scoreValue.makeNotApplicable();
    }

    if (securityTestingScoreValue.isUnknown() || vulnerabilities.isUnknown()) {
      return scoreValue.set(MIN);
    }

    boolean goodTesting = securityTestingScoreValue.get() >= GOOD_TESTING_THRESHOLD;
    boolean hasRecentVulnerabilities = hasRecent(vulnerabilities);

    if (goodTesting) {
      return scoreValue.set(hasRecentVulnerabilities ? HIGH : MAX);
    }

    return scoreValue.set(hasRecentVulnerabilities ? MIN : LOW);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }

    if (o instanceof VulnerabilityDiscoveryAndSecurityTestingScore == false) {
      return false;
    }

    if (!super.equals(o)) {
      return false;
    }

    VulnerabilityDiscoveryAndSecurityTestingScore that
        = (VulnerabilityDiscoveryAndSecurityTestingScore) o;

    return Objects.equals(securityTestingScore, that.securityTestingScore);
  }

  @Override
  public int hashCode() {
    return Objects.hash(super.hashCode(), securityTestingScore);
  }

  /**
   * Checks if there are recent vulnerabilities.
   *
   * @param vulnerabilities The vulnerabilities to be checked.
   * @return True if there are recent vulnerabilities, false otherwise.
   */
  private static boolean hasRecent(Value<Vulnerabilities> vulnerabilities) {
    Date date = Date.from(Instant.now().minus(TIME_FRAME));

    for (Vulnerability vulnerability : vulnerabilities.get()) {
      if (vulnerability.published().filter(published -> published.after(date)).isPresent()) {
        return true;
      }
    }

    return false;
  }
}
