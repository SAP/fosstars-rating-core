package com.sap.oss.phosphor.fosstars.model.score.oss;

import static com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures.ARTIFACT_VERSION;
import static com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures.VULNERABILITIES_IN_ARTIFACT;
import static com.sap.oss.phosphor.fosstars.model.other.Utils.findValue;

import com.sap.oss.phosphor.fosstars.model.Score;
import com.sap.oss.phosphor.fosstars.model.Value;
import com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures;
import com.sap.oss.phosphor.fosstars.model.score.FeatureBasedScore;
import com.sap.oss.phosphor.fosstars.model.value.ArtifactVersion;
import com.sap.oss.phosphor.fosstars.model.value.CVSS;
import com.sap.oss.phosphor.fosstars.model.value.ScoreValue;
import com.sap.oss.phosphor.fosstars.model.value.SemanticVersion;
import com.sap.oss.phosphor.fosstars.model.value.VersionRange;
import com.sap.oss.phosphor.fosstars.model.value.Vulnerabilities;
import com.sap.oss.phosphor.fosstars.model.value.Vulnerability;
import java.util.List;
import java.util.Optional;
import java.util.Set;

/**
 * The scoring function assesses known vulnerabilities and their severity.
 * The scoring functions uses the following features:
 * <ul>
 *   <li>{@link OssFeatures#ARTIFACT_VERSION}</li>
 *   <li>{@link OssFeatures#VULNERABILITIES_IN_ARTIFACT}</li>
 * </ul>
 */
public class ArtifactVersionVulnerabilityScore extends FeatureBasedScore {

  private static final double NO_CPE_NO_VULNERABILITY_SCORE_VALUE = 8;
  private static final int HIGH_SEVERE_CVE_PENALTY = 10;
  private static final int MID_SEVERE_CVE_PENALTY = 5;
  private static final int LOW_SEVERE_CVE_PENALTY = 2;
  private static final double HIGH_SEVERITY_THRESHOLD = 7.0;
  private static final int MID_SEVERITY_THRESHOLD = 4;

  /**
   * Initializes a new score.
   */
  public ArtifactVersionVulnerabilityScore() {
    super("Known vulnerabilities for an artifact of an open-source project",
        VULNERABILITIES_IN_ARTIFACT, ARTIFACT_VERSION);
  }

  @Override
  public ScoreValue calculate(Value<?>... values) {
    Value<ArtifactVersion> versionValue = findValue(values, ARTIFACT_VERSION,
        "Hey! Give me info about used artifact version!");
    Value<Vulnerabilities> vulnerabilities = findValue(values, VULNERABILITIES_IN_ARTIFACT,
        "Hey! Give me info about artifact vulnerabilities!");

    if (versionValue.isUnknown() || versionValue.isNotApplicable()) {
      return scoreValue(Score.MIN, versionValue, vulnerabilities)
          .makeUnknown().withMinConfidence()
          .explain("Unknown version value.");
    }

    if (vulnerabilities.isUnknown()) {
      return scoreValue(Score.MIN, versionValue, vulnerabilities)
          .makeUnknown().withMinConfidence()
          .explain("Unknown vulnerabilities value.");
    }

    if (vulnerabilities.get().isEmpty()) {
      // if somehow possible it should be verified that CPE mapping was successful
      return scoreValue(NO_CPE_NO_VULNERABILITY_SCORE_VALUE, versionValue, vulnerabilities)
          .confidence(8)
          .explain("No vulnerabilities for project found.");
    }

    Optional<SemanticVersion> semVer = SemanticVersion.parse(versionValue.get().version());
    if (!semVer.isPresent()) {
      return scoreValue(Score.MIN, versionValue, vulnerabilities)
          .makeUnknown().withMinConfidence()
          .explain("Version value is not parsable (not in semantic version format).");
    }

    return calculateScoreValue(versionValue, vulnerabilities, semVer.get());
  }


  private ScoreValue calculateScoreValue(Value<ArtifactVersion> versionValue,
      Value<Vulnerabilities> vulnerabilities, SemanticVersion usedVersion) {

    int penalty = 0;
    int issues = 0;
    int highSeverityIssues = 0;
    int mediumSeverityIssues = 0;
    int lowSeverityIssues = 0;

    Set<Vulnerability> entries = vulnerabilities.get().entries();
    for (Vulnerability entry : entries) {
      List<VersionRange> vulnerableVersions = entry.vulnerableVersions();
      for (VersionRange vulnerableVersion : vulnerableVersions) {
        Optional<SemanticVersion> start =
            vulnerableVersion.start().flatMap(SemanticVersion::parse);
        Optional<SemanticVersion> end =
            vulnerableVersion.end().flatMap(SemanticVersion::parse);

        if (start.isPresent() && end.isPresent()) {
          boolean inRange = usedVersion.isInRange(start.get(), end.get());
          if (!inRange) {
            continue;
          }

          issues++;
          Optional<CVSS> cvss = entry.cvss();
          double cvssValue = !cvss.isPresent() ? CVSS.MAX : cvss.get().value();

          if (cvssValue >= HIGH_SEVERITY_THRESHOLD) {
            highSeverityIssues++;
            penalty += HIGH_SEVERE_CVE_PENALTY;
          } else if (cvssValue >= MID_SEVERITY_THRESHOLD) {
            mediumSeverityIssues++;
            penalty += MID_SEVERE_CVE_PENALTY;
          } else {
            lowSeverityIssues++;
            penalty += LOW_SEVERE_CVE_PENALTY;
          }
        }
      }
    }

    String message = String.format("Found %d vulnerabilities affecting the given version ", issues);
    if (issues > 0) {
      message += String.format("(%d of %d for project; %d high, %d medium, %d low for version).",
          issues, entries.size(),
          highSeverityIssues, mediumSeverityIssues, lowSeverityIssues);
    } else {
      message += String.format("(%d for project).", entries.size());
    }
    logger.info(message);

    return scoreValue(Score.MAX - penalty, vulnerabilities, versionValue).explain(message);
  }
}
