package com.sap.oss.phosphor.fosstars.model.score.oss;

import static com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures.ARTIFACT_VERSION;
import static com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures.VULNERABILITIES;
import static com.sap.oss.phosphor.fosstars.model.other.Utils.findValue;

import com.sap.oss.phosphor.fosstars.model.Score;
import com.sap.oss.phosphor.fosstars.model.Value;
import com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures;
import com.sap.oss.phosphor.fosstars.model.score.FeatureBasedScore;
import com.sap.oss.phosphor.fosstars.model.value.CVSS;
import com.sap.oss.phosphor.fosstars.model.value.ScoreValue;
import com.sap.oss.phosphor.fosstars.model.value.SemanticVersion;
import com.sap.oss.phosphor.fosstars.model.value.VersionRange;
import com.sap.oss.phosphor.fosstars.model.value.Vulnerabilities;
import com.sap.oss.phosphor.fosstars.model.value.Vulnerability;
import java.util.List;
import java.util.Optional;
import java.util.Set;

/**
 * The scores assesses if the artifact has known vulnerabilities and the severity of those.
 * <ul>
 *   <li>{@link OssFeatures#ARTIFACT_VERSION}</li>
 *   <li>{@link OssFeatures#VULNERABILITIES}</li>
 * </ul>
 */
public class ArtifactVersionVulnerabilityScore extends FeatureBasedScore {

  private static final double NO_CPE_NO_VULNERABILITY_SCORE_VALUE = 8;

  /**
   * Initializes a new score.
   */
  public ArtifactVersionVulnerabilityScore() {
    // FIXME: name is only a working name and require change
    super("Known vulnerabilities for an artifact of an open-source project",
        VULNERABILITIES, ARTIFACT_VERSION);
  }

  @Override
  public ScoreValue calculate(Value<?>... values) {
    Value<String> versionValue = findValue(values, ARTIFACT_VERSION,
        "Hey! Give me info about used artifact version!");
    Value<Vulnerabilities> vulnerabilities = findValue(values, VULNERABILITIES,
        "Hey! Give me info about vulnerabilities!");

    if (versionValue.isUnknown() || versionValue.isNotApplicable()) {
      // TODO (mibo): Improve/change?!
      return scoreValue(Score.MIN, versionValue, vulnerabilities)
          .makeUnknown().withMinConfidence()
          .explain("Unknown version value.");
    }

    if (vulnerabilities.isUnknown()) {
      return scoreValue(Score.MIN, versionValue, vulnerabilities)
          .makeUnknown().withMinConfidence()
          .explain("Unknown vulnerabilities value.");
    }

    if (vulnerabilities.get().isEmpty()) {
      // if somehow possible it should be verified that CPE mapping was successful
      return scoreValue(NO_CPE_NO_VULNERABILITY_SCORE_VALUE, versionValue, vulnerabilities)
          .confidence(8)
          .explain("No vulnerabilities for project found.");
    }

    Optional<SemanticVersion> semVer = SemanticVersion.parse(versionValue.get());
    if (!semVer.isPresent()) {
      return scoreValue(Score.MIN, versionValue, vulnerabilities)
          .makeUnknown().withMinConfidence()
          .explain("Version value is not parsable (not in semantic version format).");
    }

    return calculateScoreValue(versionValue, vulnerabilities, semVer.get());
  }


  private ScoreValue calculateScoreValue(Value<String> versionValue,
      Value<Vulnerabilities> vulnerabilities, SemanticVersion usedVersion) {

    int penalty = 0;
    int issues = 0;
    int highSeverityIssues = 0;
    int mediumSeverityIssues = 0;
    int lowSeverityIssues = 0;

    Set<Vulnerability> entries = vulnerabilities.get().entries();
    for (Vulnerability entry : entries) {
      List<VersionRange> vulnerableVersions = entry.vulnerableVersions();
      for (VersionRange vulnerableVersion : vulnerableVersions) {
        Optional<SemanticVersion> start = SemanticVersion.parse(vulnerableVersion.versionStart());
        Optional<SemanticVersion> end = SemanticVersion.parse(vulnerableVersion.versionEnd());

        if (start.isPresent() && end.isPresent()) {
          boolean inRange = usedVersion.isInRange(start.get(), end.get());
          if (inRange) {
            issues++;
            CVSS cvss = entry.cvss();
            double cvssValue = cvss.isUnknown() ? CVSS.MAX : cvss.value();

            if (cvssValue >= 7.0) {
              highSeverityIssues++;
              penalty += 10;
            } else if (cvssValue >= 4) {
              mediumSeverityIssues++;
              penalty += 5;
            } else {
              lowSeverityIssues++;
              penalty += 2;
            }
          }
        }
      }
    }

    String message = String.format("Found %s vulnerabilities for given version ", issues);
    if (issues > 0) {
      message += String.format("(%s of %s for project; %s high, %s medium, %s low for version).",
          issues, entries.size(),
          highSeverityIssues, mediumSeverityIssues, lowSeverityIssues);
    } else {
      message += String.format("(%s for project).", entries.size());
    }
    logger.info(message);

    return scoreValue(Score.MAX - penalty, vulnerabilities, versionValue).explain(message);
  }
}
