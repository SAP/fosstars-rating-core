package com.sap.oss.phosphor.fosstars.data.github;

import static com.sap.oss.phosphor.fosstars.model.feature.oss.OssFeatures.ENABLED_VULNERABILITY_ALERTS_ON_GITHUB;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

import com.sap.oss.phosphor.fosstars.model.Value;
import com.sap.oss.phosphor.fosstars.model.ValueSet;
import com.sap.oss.phosphor.fosstars.model.subject.oss.GitHubProject;
import java.io.IOException;
import java.util.Optional;
import org.apache.http.StatusLine;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.impl.client.CloseableHttpClient;
import org.junit.Test;

public class VulnerabilityAlertsInfoTest extends TestGitHubDataFetcherHolder {

  @Test
  public void testSupportedFeatures() {
    VulnerabilityAlertsInfo provider = new VulnerabilityAlertsInfo(fetcher, "xyz");
    assertTrue(provider.supportedFeatures().contains(ENABLED_VULNERABILITY_ALERTS_ON_GITHUB));
  }

  @Test
  public void testWithEnabledAlerts() throws IOException {
    StatusLine statusLine = mock(StatusLine.class);
    when(statusLine.getStatusCode()).thenReturn(204);

    CloseableHttpResponse response = mock(CloseableHttpResponse.class);
    when(response.getStatusLine()).thenReturn(statusLine);

    CloseableHttpClient client = mock(CloseableHttpClient.class);
    when(client.execute(any())).thenReturn(response);

    VulnerabilityAlertsInfo provider = spy(new VulnerabilityAlertsInfo(fetcher, "xyz"));
    when(provider.httpClient()).thenReturn(client);

    GitHubProject project = new GitHubProject("test", "project");
    ValueSet values = provider.fetchValuesFor(project);
    Optional<Value<Boolean>> something = values.of(ENABLED_VULNERABILITY_ALERTS_ON_GITHUB);
    assertTrue(something.isPresent());
    Value<Boolean> value = something.get();
    assertFalse(value.isUnknown());
    assertFalse(value.isNotApplicable());
    assertTrue(value.get());
  }

  @Test
  public void testWithDisabledAlerts() throws IOException {
    StatusLine statusLine = mock(StatusLine.class);
    when(statusLine.getStatusCode()).thenReturn(404);

    CloseableHttpResponse response = mock(CloseableHttpResponse.class);
    when(response.getStatusLine()).thenReturn(statusLine);

    CloseableHttpClient client = mock(CloseableHttpClient.class);
    when(client.execute(any())).thenReturn(response);

    VulnerabilityAlertsInfo provider = spy(new VulnerabilityAlertsInfo(fetcher, "xyz"));
    when(provider.httpClient()).thenReturn(client);

    GitHubProject project = new GitHubProject("test", "project");
    ValueSet values = provider.fetchValuesFor(project);
    Optional<Value<Boolean>> something = values.of(ENABLED_VULNERABILITY_ALERTS_ON_GITHUB);
    assertTrue(something.isPresent());
    Value<Boolean> value = something.get();
    assertFalse(value.isUnknown());
    assertFalse(value.isNotApplicable());
    assertFalse(value.get());
  }

  @Test
  public void testWithError() throws IOException {
    CloseableHttpClient client = mock(CloseableHttpClient.class);
    when(client.execute(any())).thenThrow(IOException.class);

    VulnerabilityAlertsInfo provider = spy(new VulnerabilityAlertsInfo(fetcher, "xyz"));
    when(provider.httpClient()).thenReturn(client);

    GitHubProject project = new GitHubProject("test", "project");
    ValueSet values = provider.fetchValuesFor(project);
    Optional<Value<Boolean>> something = values.of(ENABLED_VULNERABILITY_ALERTS_ON_GITHUB);
    assertTrue(something.isPresent());
    Value<Boolean> value = something.get();
    assertTrue(value.isUnknown());
  }
}